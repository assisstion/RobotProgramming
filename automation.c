#pragma config(Hubs,  S4, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S3,     HTIRS2,         sensorI2CCustom)
#pragma config(Sensor, S4,     ,               sensorI2CMuxController)
#pragma config(Motor,  motorA,          irArm,         tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,          clawSide,      tmotorNXT, openLoop)
#pragma config(Motor,  motorC,          clawFrontLeft, tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S4_C1_1,     rightWheel,    tmotorTetrix, openLoop, driveRight, encoder)
#pragma config(Motor,  mtr_S4_C1_2,     leftWheel,     tmotorTetrix, openLoop, driveLeft, encoder)
#pragma config(Motor,  mtr_S4_C2_1,     pulley1,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C2_2,     pulley2,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C3_1,     collector1,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C3_2,     collector2,    tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S4_C4_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S4_C4_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S4_C4_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S4_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S4_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S4_C4_6,    Center,               tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
 *	 Author:		Markus Feng & Alex Guo
 *	 Team:		DA Robotics
 *	 Project:		Cascade Effect 2014
 *	 Program:		Robot Controllers
 */

#include "hitechnic-irseeker-v2.h"
//#include "JoystickDriver.c" //unnecessary include

const int maxSpeed = 100;

//const int wheelDist = 32.5; //unused distance between wheels

const int irRegion = 5;

const float wheelCircum = 31.415926;

/*
* Finds the direction given by the IR Detector
* returns{
* 0: false
* 1: true
* -1: error
* }
*/
int irFound(int value){
	int _dirAC = HTIRS2readACDir(HTIRS2);
	if (_dirAC <= 0){
		return -1;
	}
	if(_dirAC == value){
		return 1;
	}
	else{
		return 0;
	}
}

/*
* Travels a set amount of distance, based on encoder rotations
* Note that this method does not stop the robot before returning
* LeftValues{
* leftSpeed: speed the left wheel motor moves at (-100 to 100)
* rightSpeed: speed the right wheel motor moves at (-100 to 100)
* distance: distance to travel in centimeters (negative value for going backwards, positive for going forwards)
* parameter: {
* 0: regular travelling
* 1: unused
* 2: stop on infrared detection
* }
* trueValue: if true, distance is measured in encoder value instead of distance
* }
* returns: true if the IR beacon is in detection, false otherwise
*/
bool travelDistance(int leftSpeed, int rightSpeed, float distance, int mode, bool trueValue){
	//Sets the encoder values to 0
	nMotorEncoder[leftWheel] = 0;
	nMotorEncoder[rightWheel] = 0;

	//Sets the speed
	motor[leftWheel] = -leftSpeed;
	motor[rightWheel] = rightSpeed;

	//Constant for adjusting distance (to account for various real life factors)
	float constant = 1.16; //old: 1.10, 1.16
	if(!trueValue){
		//Using encoder values instead
		constant = 1120/wheelCircum;
	}
	//Forward movement
	if(distance >= 0){
		//Run until encoder reaches value or, in the case of IR detection (mode 2), IR beacon found
		while((mode != 2 || irFound(irRegion) != 1) && -1*nMotorEncoder[leftWheel] < distance*constant
			&& nMotorEncoder[rightWheel] < distance*constant){
				//Prints debug information
			nxtDisplayTextLine(0, "%d", motor[leftWheel]);
			nxtDisplayTextLine(1, "%d", motor[rightWheel]);
			nxtDisplayTextLine(2, "%d", nMotorEncoder[leftWheel]);
			nxtDisplayTextLine(3, "%d", nMotorEncoder[rightWheel]);
			nxtDisplayTextLine(4, "%d", distance*constant);
		}
	}
	//Backward movement
	else{
		//Run until encoder reaches value or, in the case of IR detection (mode 2), IR beacon found
		while((mode != 2 || irFound(irRegion) != 1) && nMotorEncoder[leftWheel] < -1*distance*constant
			&& -1*nMotorEncoder[rightWheel] < -1*distance*constant){
				//Prints debug information
			nxtDisplayTextLine(0, "%d", motor[leftWheel]);
			nxtDisplayTextLine(1, "%d", motor[rightWheel]);
			nxtDisplayTextLine(2, "%d", nMotorEncoder[leftWheel]);
			nxtDisplayTextLine(3, "%d", nMotorEncoder[rightWheel]);
			nxtDisplayTextLine(4, "%d", distance*constant);
		}
	}
	//Returns if the IR beacon was found
	return irFound(irRegion) == 1;
}

/*
* Turn a set number of degrees; As a pivotal rotation, one wheel turns, while the other wheel remains in place
* LeftValues{
* degrees: the number of degrees to turn
* speed: the speed of the turning wheel
* direction{
* true: turn left (right wheel on)
* false: turn right (left wheel on)
* }
* }
*/
void turn(float degrees, int turnSpeed, bool direction){
	//Calculates distance to turn
	//Based on encoder with 1120 pulses per rotation
	float dist = 3.14*2*4550*degrees/1413;

	//Turns differently based on left or right
	if(direction){
		travelDistance(0, turnSpeed*2, dist, false, true);
		}else{
		travelDistance(turnSpeed*2, 0, dist, false, true);
	}
}

/*
* Raises or lowers the vertical lift
* Note that lowering is affected by gravity, and therefore much faster
* The ms leftValue should be experimentally decided to raise and lower into optional positions
* LeftValues{
* ms: the number of milliseconds to raise or lower the vertical lift
* up{
* true: raise the vertical lift upwards
* false: lower the vertical lift downwards
* }
* }
*/
void raise(int ms, bool up){
	if(up){
		//Sets the center servo to the up position
		servo[Center] = 125;
		wait1Msec(200);
		//Raises the pulleys
		motor[pulley1] = maxSpeed;
		motor[pulley2] = -maxSpeed;
	}
	else{
		//Sets the center servo to the up position
		servo[Center] = 125;
		//Lowers the pulleys
		motor[pulley1] = -maxSpeed;
		motor[pulley2] = maxSpeed;
	}
	wait1Msec(ms);
	//Stops the pulleys
	motor[pulley1] = 0;
	motor[pulley2] = 0;
	//If lowering, lowers the center servo
	if(!up){
		servo[Center] = 70;
	}
}


	/*
	* mode{
	* 0: not turning / arc
	* 1: turning
	* 2: until infrared
	* 3: distance sensor
	* 4: dump ball
	* }
	*/
//Default speed for movement
const int speed = 40;

//Length of the parameter array
int parameterlen = 12;
int parameter[] = {80 , -90, 40, 40, -45, 45, 30, 45, 30, 90, 100, 100}; //distance/values of until (centimeters for straight, degrees for turn)
int leftValue[] = {speed, -speed, speed, speed, 0 , speed, speed, speed, speed, speed, speed, speed}; // left speed
int rightValue[] = {speed, 0 , speed, speed, -speed, speed, speed, 0 , speed, 0 , speed, speed}; // right speed
int mode[] = {0 ,1 ,2 ,0 ,1 ,2 ,0 ,1 , 2 ,1 ,0 ,0 }; // see above

//Length of branches array
int brancheslen = 3;
int branches[] = {2, 5, 8}; //sub-instruction groups (correspond to break of infrared)
int branchLength[] = {6, 6, 6}; // length of sub-instruction group

int branchParameter[] = {-16 ,90 , -0 , 4400, 180 , 200 , -22 , 90 , -0 , 4400, 180 , 200 , -16 , 87 , -10 , 4400, 175 , 200}; //sub-instruction parameter
int branchLeftValue[] = {-speed, 0 , -speed, 2500, 0 , speed*3, -speed, 0 , -speed, 2500, 0 , speed*3, -speed, 0 , -speed, 2500, 0 , speed*3}; //sub-instruction leftValue
int branchRightValue[] = {-speed, speed, -speed, 12 , speed, speed*3, -speed, speed, -speed, 17 , speed, speed*3, -speed, speed, -speed, 15 , speed, speed*3}; //sub-instruction rightValue
int branchMode[] = {0 ,1 , 0 ,4 , 1 , 0 , 0 , 1 , 0 , 4 , 1 , 0 , 0 , 1 , 0 , 4 , 1 , 0}; //sub-instruction mode


task main() {
	waitForStart(); //Enable for competition

	//Move servos
	servo[servo2] = 180;
	servo[Center] = 70;
	//wait1Msec();

	nMotorEncoder[irArm] = 0;
	motor[irArm] = 40;
	while(nMotorEncoder[irArm] < 140){
		nxtDisplayTextLine(0, "%d", nMotorEncoder[irArm]);
	}
	motor[irArm] = 0;
	//motor[irArm] = 10;
	//wait1Msec(795);
	//motor[irArm] = 0;

	//short basej1_y2 = joystick.joy1_y2;
	//short basej1_y1 = joystick.joy1_y1;


	/*
	* 0: not turning / arc
	* 1: turning
	* 2: until infrared
	* 3: distance sensor
	* 4: dump ball
	*/
	int i = 0;

	for(; i < parameterlen; i++){

		if(mode[i] == 0){
			travelDistance(leftValue[i], rightValue[i], parameter[i], 0, false);
		}
		else if(mode[i] == 1){
			if(leftValue[i] == 0 && rightValue[i] != 0){
				turn(parameter[i], rightValue[i], true);
			}
			else if(leftValue[i] !=0 && rightValue[i] == 0){
				turn(parameter[i], leftValue[i], false);
			}
			else{
				//print("Error in data[][]...");
			}
		}
		else if(mode[i] == 2){
			if(travelDistance(leftValue[i], rightValue[i], parameter[i], 2, false)){
				motor[leftWheel] = 0;
				motor[rightWheel] = 0;
				wait1Msec(200);
				break;
			}
		}
		else if(mode[i] == 3){
			travelDistance(leftValue[i], rightValue[i], parameter[i], 3, false);
		}
		else if(mode[i] == 4){
			wait1Msec(200);
		}
		motor[leftWheel] = 0;
		motor[rightWheel] = 0;
		wait1Msec(200);
	}

	int totalLen = 0;
	int insLen = 0;
	for(int j = 0; j < brancheslen; j++){
		if(branches[j] == i){
				insLen = branchLength[j];
				break;
		}
		else{
			totalLen += branchLength[j];
		}
	}



	for(int k = totalLen; k < totalLen + insLen; k++){
		nxtDisplayTextLine(5, "%d", k);
		if(branchMode[k] == 0){
			travelDistance(branchLeftValue[k], branchRightValue[k], branchParameter[k], 0, false);
		}
		else if(branchMode[k] == 1){
			if(branchLeftValue[k] == 0 && branchRightValue[k] != 0){
				turn(branchParameter[k], branchRightValue[k], true);
			}
			else if(branchLeftValue[k] !=0 && branchRightValue[k] == 0){
				turn(branchParameter[k], branchLeftValue[k], false);
			}
			else{
				//print("Error in data[][]...");
			}
		}
		else if(branchMode[k] == 2){
			if(travelDistance(branchLeftValue[k], branchRightValue[k], branchParameter[k], 2, false)){
				break;
			}
		}
		else if(branchMode[k] == 3){
			travelDistance(branchLeftValue[k], branchRightValue[k], branchParameter[k], 3, false);
		}
		else if(branchMode[k] == 4){
			raise(branchParameter[k], true);
			travelDistance(-speed/2, -speed/2, -branchRightValue[k], 0, false);
			motor[leftWheel] = 0;
			motor[rightWheel] = 0;
			wait1Msec(200);
			servo[servo2] = 0;
			wait1Msec(2500);
			//servo[servo2] = 180;
			//wait1Msec(200);
			travelDistance(speed/2, speed/2, branchRightValue[k], 0, false);
			motor[leftWheel] = 0;
			motor[rightWheel] = 0;
			wait1Msec(200);
			raise(branchLeftValue[k], false);
			//wait1Msec(200);
		}
		motor[leftWheel] = 0;
		motor[rightWheel] = 0;
		wait1Msec(200);
	}
	nxtDisplayTextLine(0, "%d", 1);
	nxtDisplayTextLine(1, "%d", nMotorEncoder[leftWheel]);
	nxtDisplayTextLine(2, "%d", nMotorEncoder[rightWheel]);
	motor[leftWheel] = 0;
	motor[rightWheel] = 0;
	wait1Msec(10000);
	//1848
}
